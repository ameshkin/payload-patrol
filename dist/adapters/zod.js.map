{"version":3,"sources":["../../src/adapters/zod.ts"],"names":[],"mappings":"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","file":"zod.js","sourcesContent":["/**\n * Zod adapter for Payload Patrol\n * Lightweight integration for schema-level validation\n */\n\nimport { z } from \"zod\";\nimport { auditPayload } from \"../index\";\nimport type { CheckName, AdapterMode } from \"../types\";\n\nexport interface ZodSafeStringOptions {\n  /** Maximum string length */\n  maxLength?: number;\n  /** Minimum string length */\n  minLength?: number;\n  /** Block SQL injection patterns (default: true) */\n  blockSQLi?: boolean;\n  /** Block XSS/script patterns (default: true) */\n  blockXSS?: boolean;\n  /** Allow HTML tags (default: false) */\n  allowHTML?: boolean;\n  /** Check profanity (default: false) */\n  checkProfanity?: boolean;\n  /** Maximum character count */\n  maxChars?: number;\n  /** Maximum word count */\n  maxWords?: number;\n  /** Allowlist of terms */\n  allowlist?: string[];\n  /** Adapter mode (default: \"block\") */\n  adapter?: AdapterMode;\n  /** Custom error message */\n  message?: string;\n}\n\n/**\n * Create a safe string schema with Payload Patrol validation\n * \n * @example\n * ```ts\n * const schema = z.object({\n *   name: zSafeString({ maxLength: 128 }),\n *   email: zSafeString({ allowHTML: false }),\n *   bio: zSafeString({ maxChars: 500, checkProfanity: true })\n * });\n * ```\n */\nexport function zSafeString(opts: ZodSafeStringOptions = {}) {\n  const {\n    maxLength,\n    minLength,\n    blockSQLi = true,\n    blockXSS = true,\n    allowHTML = false,\n    checkProfanity = false,\n    maxChars,\n    maxWords,\n    allowlist,\n    adapter = \"block\",\n    message,\n  } = opts;\n\n  let schema = z.string();\n\n  // Apply basic string validations\n  if (minLength !== undefined) {\n    schema = schema.min(minLength);\n  }\n  if (maxLength !== undefined) {\n    schema = schema.max(maxLength);\n  }\n\n  // Add Payload Patrol refinement\n  return schema.refine(\n    async (value) => {\n      const checks: CheckName[] = [];\n      \n      if (checkProfanity) checks.push(\"badwords\");\n      if (blockSQLi) checks.push(\"sql\");\n      if (blockXSS) checks.push(\"scripts\");\n      if (!allowHTML) checks.push(\"html\");\n      if (maxChars || maxWords) checks.push(\"limit\");\n\n      const result = await auditPayload(value, {\n        adapter,\n        checks,\n        context: {\n          limit: { maxChars, maxWords },\n          allowlist,\n        },\n      });\n\n      return result.ok;\n    },\n    {\n      message: message || \"Input contains unsafe content\",\n      // Provide detailed error via params\n      params: {\n        code: \"unsafe_content\",\n      },\n    }\n  );\n}\n\n/**\n * Create a safe object schema that validates all string fields\n * \n * @example\n * ```ts\n * const schema = zSafeObject({\n *   name: z.string(),\n *   email: z.string().email(),\n *   age: z.number()\n * }, { blockXSS: true, blockSQLi: true });\n * ```\n */\nexport function zSafeObject<T extends z.ZodRawShape>(\n  shape: T,\n  opts: Omit<ZodSafeStringOptions, \"maxLength\" | \"minLength\"> = {}\n) {\n  return z.object(shape).refine(\n    async (value) => {\n      const result = await auditPayload(value, {\n        adapter: opts.adapter || \"block\",\n        checks: [\n          ...(opts.checkProfanity ? [\"badwords\" as CheckName] : []),\n          ...(opts.blockSQLi !== false ? [\"sql\" as CheckName] : []),\n          ...(opts.blockXSS !== false ? [\"scripts\" as CheckName] : []),\n          ...(opts.allowHTML === false ? [\"html\" as CheckName] : []),\n        ],\n        context: {\n          limit: { maxChars: opts.maxChars, maxWords: opts.maxWords },\n          allowlist: opts.allowlist,\n        },\n      });\n      return result.ok;\n    },\n    {\n      message: opts.message || \"Object contains unsafe content\",\n      params: {\n        code: \"unsafe_content\",\n      },\n    }\n  );\n}\n\n/**\n * Transform that strips unsafe content instead of blocking\n * \n * @example\n * ```ts\n * const schema = z.string().transform(zStripUnsafe());\n * ```\n */\nexport function zStripUnsafe(opts: Omit<ZodSafeStringOptions, \"adapter\"> = {}) {\n  return async (value: string) => {\n    const checks: CheckName[] = [];\n    \n    if (opts.blockXSS !== false) checks.push(\"scripts\");\n    if (!opts.allowHTML) checks.push(\"html\");\n\n    const result = await auditPayload(value, {\n      adapter: \"strip\",\n      checks,\n      context: {\n        allowlist: opts.allowlist,\n      },\n    });\n\n    return (result.value as string) || value;\n  };\n}\n"]}